package cstruct

import (
	auth "Cloud/authenticate"
	conf "Cloud/config"
	trans "Cloud/transmit"
	"os"
	"path/filepath"
	"strings"
)

/* CUSER DECLARATION
 * id       : primary key for cuser
 * listen   : main connection for cuser
 * username : username
 * token    : generated by server randomly whenever login, used for encryption
 * curpath  : current path the user is looking
 * worklist : current download/upload processes' list
 * filelist : list of the files owned by this user
 */

type cuser struct {
	id       int64
	listen   trans.Transmitable
	username string
	token    string
	curpath  string
	worklist []trans.Transmitable
	filelist []UFile
}

/* CUSER METHODS
 * CONSTRUCTOR: NewCUser(id 			int64,
						username 	string,
						curpath 	string) *cuser
 * MODIFIER: Set[VALUE] (v VALUE_TYPE) 		bool
			 AddUFile	(f *ufile) 	   		bool
 * VERIFIER: Verify		(psw string)   		bool
*/

type User interface {
	GetUsername() string
	GetId() int64
	GetWorkList() []trans.Transmitable
	GetFilelist() []UFile
	GetAbsPath() string
	GoToUpper()
	GoToPath(string) bool
	SetPath(string) bool
	SetToken(string) bool
	SetListener(trans.Transmitable) bool
	Verify(string) bool
	AddUFile(UFile) bool
	RemoveUFile(UFile) bool
	AddTransmit(trans.Transmitable) bool
	RemoveTransmit(trans.Transmitable) bool
	DealWithRequests()
	Logout()
}

func NewCUser(username string, curpath string) *cuser {
	u := new(cuser)
	u.listen = nil
	u.id = 1 //TODO
	u.username = username
	u.curpath = curpath
	u.worklist = nil
	u.filelist = nil
	u.token = ""
	return u
}

func (u *cuser) GetWorkList() []trans.Transmitable {
	return u.worklist
}

func (u *cuser) GetFileList() []UFile {
	return u.filelist
}

func (u *cuser) GetAbsPath() string {
	return conf.USER_FOLDER + u.username + u.curpath
}

func (u *cuser) SetListener(t trans.Transmitable) bool {
	u.listen = t
	return true
}

func (u *cuser) SetPath(path string) bool {
	u.curpath = path
	return true
}

func getCurrentDirectory() (string, bool) {
	dir, err := filepath.Abs(filepath.Dir(os.Args[0]))
	if err != nil {
		return "", false
	}
	return strings.Replace(dir, "\\", "/", -1), true
}

func (u *cuser) GoToUpper() {
	if strings.Count(u.curpath, "/") <= 1 {
		u.curpath = "/"
	} else {
		cp := strings.LastIndex(u.curpath, "/")
		if cp == -1 {
			return
		}
		u.curpath = u.curpath[:cp]
	}
}

func (u *cuser) GoToPath(path string) bool {
	var err1, err2 error = nil, nil
	if path[0] == '/' {
		err1 = os.Chdir(conf.USER_FOLDER + u.username + path)
	} else {
		err2 = os.Chdir(path)
	}
	dir, suc := getCurrentDirectory()
	if string(dir[:len(conf.USER_FOLDER)+len(u.username)]) != (conf.USER_FOLDER+u.username) ||
		err1 != nil || err2 != nil || suc != true {
		return false
	} else {
		u.curpath = dir[len(conf.USER_FOLDER)+len(u.username):]
		return true
	}
}

func (u *cuser) SetToken(t string) bool {
	u.token = t
	return true
}

func (u *cuser) GetUsername() string {
	return u.username
}

func (u *cuser) GetFilelist() []UFile {
	return u.filelist
}

func (u *cuser) GetId() int64 {
	return u.id
}

func (u *cuser) GetToken() string {
	return u.token
}

func (u *cuser) Verify(psw string) bool {
	// TODO
	return true
}

func (u *cuser) AddUFile(f UFile) bool {
	if u.filelist == nil {
		u.filelist = make([]UFile, 0, 10)
	}
	u.filelist = AppendUFile(u.filelist, f)
	return (u.filelist != nil)
}

func (u *cuser) RemoveUFile(f UFile) bool {
	for i, uf := range u.filelist {
		if uf == f {
			u.filelist = append(u.filelist[:i], u.filelist[i:]...)
			return true
		}
	}
	return false
}

func (u *cuser) AddTransmit(t trans.Transmitable) bool {
	if u.worklist == nil {
		u.worklist = make([]trans.Transmitable, 0, 2)
	}
	tempLen := len(u.worklist)
	u.worklist = AppendTransmitable(u.worklist, t)
	return len(u.worklist) != tempLen
}

func (u *cuser) RemoveTransmit(t trans.Transmitable) bool {
	for i, ut := range u.worklist {
		if ut == t {
			u.worklist = append(u.worklist[:i], u.worklist[i:]...)
			return true
		}
	}
	return false
}

func (u *cuser) Logout() {
	if u.listen != nil {
		u.listen.Destroy()
	}
	for _, ut := range u.worklist {
		if ut != nil {
			ut.Destroy()
		}
	}
	u.worklist = nil
	u.token = ""
	u.id = 0xffffffff
	u.username = auth.GetRandomString(len(u.username))
}

func (u *cuser) DealWithRequests() {
	err := os.Chdir(u.GetAbsPath())
	if err != nil{
		return
	}
	for {
		u.listen.
	}
}
